require 'ribopip'

module Ribopip
  # All sorts of additional statistics:
  #   - FastQC
  #   - FieldDistri
  #   - GtSeqstat
  #   - IGV
  module Metrics # SK: rename to Metrics
    # computes quality metrics for fastq files
    class FastQC
      extend Ribopip

      # Calls fastqc
      #
      # filename - input file
      def self.compute(filename)
        fail "#{filename} does not exist." unless File.exist?(filename)
        run_cmd("fastqc #{filename}")
      end
    end

    # distribution of how many reads aligned to each ncRNA type
    class FieldDistri
      extend Ribopip

      # Computes distribution of how many reads aligned to each ncRNA type
      #
      # infile  - input file
      # outfile - output file
      # ref     - ncRNA reference (fasta)
      def self.compute(infile, outfile, ref)
        fail "#{infile} does not exist." unless File.exist?(infile)

        # build desc index, if non-existent
        run_cmd("grep -P '^>' #{ref} | tr -d '>' > #{ref}.desc") \
          unless File.exist?("#{ref}.desc")

        # extract distribution
        run_cmd("samtools view -F 4 -S #{infile} " \
                '| cut -f3 ' \
                '| sort -n ' \
                '| uniq -c ' \
                '| sort -n ' \
                "> #{outfile}")

        # merge index and distribution information
        run_cmd("#{translate_field_path} -s #{outfile} #{ref}.desc 2 > #{outfile}")
      end
    end

    # Using gt seqstat to compute and plot read length distribution
    class GtSeqstat
      extend Ribopip

      # Calls gt seqstat to compute read length distribution.
      #
      # infile  - input file
      # outfile - output file
      def self.compute(infile, outfile)
        fail "#{infile} does not exist." unless File.exist?(infile)
        run_cmd("gt seqstat -b 1 -distlen #{infile} > #{outfile}")
      end

      # Extracts min / max read length from gt seqstat output
      #
      # filename - input file
      #
      # Returns array
      def self.get_minmax_readlen(filename)
        fail "#{filename} does not exist." unless File.exist?(filename)
        file = File.read(filename)
        lower = file[/minimum\slength.*$/][/\d+/].to_i
        upper = file[/maximum\slength.*$/][/\d+/].to_i

        [lower, upper]
      end

      # Plots read length distribution generated by gt seqstat into PDF using
      # gnuplot.
      #
      # infile  - input file
      # outfile - output file
      def self.plot(infile, outfile)
        fail "#{infile} does not exist." unless File.exist?(infile)
        # convert gt seqstat output to gnuplot-compatible *.dat-file
        datfile = File.open("#{infile}.dat", 'w')
        File.readlines(infile).each do |line|
          next if line[0] == '#'
          line = line.split(/(\d+)--(\d+) (\d+)/)
          fail if line[1] != line[2]
          datfile.puts "#{line[2]} #{line[3]}"
        end
        datfile.close

        # plot
        run_cmd("env dat=#{infile}.dat pdf=#{outfile} plot_distri.gnuplot")
      end
    end

    # preprocess bam for faster display in IGV
    class IGV
      extend Ribopip

      # Deprecated: merging sorted bams
      #
      # bams    - array of .bam filenames
      # outfile - output filename
      def self.merge_bams(bams, outfile)
        run_cmd("samtools merge -f #{outfile} #{bams.join(' ')}")
      end

      # sort & index using samtools, compute using igvtools
      #
      # infile  - input file: sorted .bam
      # outtdf  - output file: .tdf
      # outwig  - output file: .wig
      # genome  - precomputed IGV .genome file
      def self.compute(infile, outtdf, outwig, genome)
        fail "#{infile} does not exist." unless File.exist?(infile)

        run_cmd("samtools index #{infile}")
        run_cmd("igvtools count -z 5 -w 1 -e 25 #{infile} #{outtdf},#{outwig} "\
                "#{genome}")
      end
    end

    # Compute rpkm
    class RPKM
      # n_mapped      - total number of mapped reads
      # annot         - path to genomic annotation (GTF)
      # featurecounts - file containing tab delimited featurecounts
      def initialize(n_mapped, annot, featurecounts)
        @n_mapped = n_mapped
        @annot_file = annot
        @ft_file = featurecounts
        @transcript_lengths = {}
        @rpkms = {}
        init_index(annot, featurecounts)
      end

      # public wrapper method
      #
      # Returns hash
      def compute
        parse_lengths
        compute_rpkms
      end

      # Parse gene lengths from annotation
      def parse_lengths
        File.readlines(@annot_file).each do |line|
          next if line[0] == '#'
          gene_id = line[/gene_id\W+\w+/].delete('"').split[1]
          gene_length = line.split[4].to_i - line.split[3].to_i
          @transcript_lengths[:"#{gene_id}"] = gene_length
        end
      end

      # Ribosome footprint densities in terms of reads per kilobase per million
      #
      # Returns hash
      def compute_rpkms
        File.readlines(@ft_file).each do |line|
          gene_id = line.split[0]
          gene_mapped = line.split[3]
          gene_length = @transcript_lengths[:"#{gene_id}"]

          # RPKM = (10^9 * C)/(N * L),where
          #   C = Number of reads mapped to a gene
          #   N = Total mapped reads in the experiment
          #   L = gene length in base-pairs for a gene
          @rpkms[:"#{gene_id}"] = (10 ^ 9 * gene_mapped) /
            (@n_mapped * gene_length)
        end
      end
    end
  end
end
